mémoire globale : 
- type de fourmis
- quelques registres (mémoire des actions précédentes notamment)


fonction de déplacement-construction (int edge) :
  si précédente action était un déplacement échoué pour cause de tunnel non construit :
    construire le tunnel à l'emplacement edge
  sinon si précédente action construction de tunnel :
    si c'est la 3 ème fois d'affilée : 
      tenter de se déplacer à edge
    sinon
      continuer de construire à edge
  sinon : 
    s'y rendre


exploratrice I : 
stratégie : 
  parcourt le graphe de manière aléatoire en partant d'un point d'eau définin par un chemin.
  stocke le chemin aller et retour pour le transmettre à la fourimilière.
  rebrousse chemin lorsque limite d'eau ou limite de mémoire atteinte
  rebrousse chemin lorsqu'on atteint un point d'eau ou de nourriture non-exploré
mémoire : 
- résultat exploration 
- chemin source de départ (à supprimer)
- chemin retour de source de départ
- chemin exploration aller 
- chemin exploration retour
- position dans le chemin
boucle :
  si trajet vers source de départ :
    suivre le chemin
  si trajet aller :
    si case de nourriture ou d'eau non-explorée : 
      la marquer comme explorée
      passer au trajet retour
    sinon si limite d'eau ou de mémoire : 
      passer au trajet retour
    sinon :
      si précédente action était un déplacement réussi :
        noter le résultat du déplacement précédent (dans tajet retour)
        choisir une direction aléatoire 
        la noter dans le chemin aller
      déplacement-construction (edge)
  si trajet retour : 
    suivre le chemin retour 

ouvrière I : 
- suit le chemin aller indiqué
- collecte de ressource
- retour selon le chemin retour
mémoire : 
- résultat collecte 
- chemin aller 
- chemin retour 
- position dans le chemin 
- taille du chemin 

cartographe I : (à voir)
- parcourt aléatoirement la carte puis revient à la fourimilière
mémoire :
- chemin détaillé (chemin aller, chemin retour, degrés des sommets, phéromones, fourimilière, eau, nourriture)
Quand on retrouve la fourmilière sur le chemin, algorithme exécuté par la reine pour reconstruire le graphe :
  La reine maintiens une liste de chemins déjà vus et des identifiants pour chaque sommet rencontré (deux sommets peuvent avoir le même identifiant si l'on ne réalise pas encore que ce sont les mêmes).
  chemins : liste de couples (chemin, id de sommet correspondant)
  adj : matrice d'adjacence entre les sommets identifiés
  Algorithme addIdentity(path) {
    // Ajoute un chemin qui part de la base et y arrive.
    nouveauté = [] // Pile vide.
    For prefix in forward_path {
      // On considère les préfixes du chemin d'aller par longueur croissante.
      Si le préfixe est nouveau (i.e., pas dans `chemins`) et le sommet atteint n'est pas la base {
        créer un nouveau sommet (identifiant frais `n`)
        ajouter l'arête correspondante dans la matrice d'adjacence
        nouveauté := n :: nouveauté
      } sinon, si le sommet atteint est la base {
        ajouter l'arête correspondante dans la matrice d'adjence, si pas déjà présente
      }
    }
    For prefix in backward_path, tant que `nouveauté` != [] {
      // On considère les préfixes du chemin de retour par longueur croissante.
      Si le préfixe est connu comme menant à un sommet `n` (grâce à `chemins`) {
        m = List.hd nouveauté
        unifier m avec n dans la matrice d'adjacence et dans `chemins`
        nouveauté := List.tl nouveauté
      }
    }
  }
